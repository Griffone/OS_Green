#include "green.h"

#include <stdio.h>

#define LOOP_COUNT		4
#define VERBOSE_HUGGER	0
#define SKIP_HUGGER		0
#define COUNTER_SIZE	1000000

int flag = 0;
green_cond_t cond;

void *test(void *arg);
void *hugger(void *arg);

void *producer(void *arg);
void *consumer(void *arg);

typedef struct counter {
	int parts[COUNTER_SIZE];	// large structure to increase chances of increment conflict
} counter;

typedef struct thread_args {
	int id;	// id of the thread
	
	// Following are optional and might not be used by all threads
	int *flag;
	counter *counters;			// One or more counters to showcase synchronization
	green_mutex_t *mutex;		// Mutex that is used for synchronization
	green_cond_t *condition;	// Conditional variable that is used for synchronization
} thread_args;

static inline void increment_counter(counter *counter) {
	for (int i = 0; i < COUNTER_SIZE; ++i) {
		counter->parts[i]++;
	}
}

/// Make sure the counter is not corrupted (all parts align)
///
/// Cleans the counter of corruption (or makes best attempt at)
/// Returns 0 if counter is valid
/// Returns an integer position of corrupted otherwise
int is_corrupted(counter *counter) {
	int c = counter->parts[0];
	int corrupted = 0;
	
	for (int i = 1; i < COUNTER_SIZE; ++i) {
		if (corrupted == 0 && counter->parts[i] != c) {
			corrupted = i;
		}
		counter->parts[i] = c;
	}
	
	return corrupted;
}

/// Increment 2 counters and checks them for corruption
///
/// First counter is incremented without synchronizing
/// Second counter is incremented synchronizing used provided mutex
/// Then checks counters for corruption and prints a message if finds any
static inline void do_counters(counter *counters, green_mutex_t *mutex) {
	increment_counter(&counters[0]);
	if (is_corrupted(&counters[0]))
		printf("Unsafe counter got corrupted!\n");
	green_mutex_lock(mutex);
	increment_counter(&counters[1]);
	if (is_corrupted(&counters[1]))
		printf("Safe counter got corrupted!\n");
	green_mutex_unlock(mutex);
}

// The variables a are declared here
// But non-static instances are allocated on the stack, which leads to segfault
// I'm not sure if its stack overflow or out-of-context data access, but static fixes it
int main() {
	// [0] - test-0 thread
	// [1] - test-1 thread
	// [2] - hugger thread (interacts with tests 0 and 1)
	// [3] - consumer
	// [4] - producer
	static green_t threads[5];
	
	// [0] and [1] are used by tests 1 and 2 as well as hugger
	// [2] is generated by producer and consumed by consumer
	static counter counters[3];
	
	// [0] is used by tests 0 and 1 to synchronize one of the counters
	// [1] is used to synchronize conditional variable for consumer-producer pair
	static green_mutex_t mutexes[2];
	
	// [0] is used to make sure test-0 runs before test-1
	// [1] is used to synchronize consumer-producer
	static green_cond_t conditions[2];
	
	for (int i = 0; i < 2; ++i) {
		for (int c = 0; c < COUNTER_SIZE; ++c) {
			counters[i].parts[c] = 0;
		}
		
		green_cond_init(&conditions[i]);
		green_mutex_init(&mutexes[i]);
	}
	
	int flags[2] = {0};
	
	
	thread_args arguments[5] = {0};
	
	
	arguments[0].id = 0;
	arguments[0].flag = &flags[0];
	arguments[0].counters = counters;	// in Rust I'd provide a slice...
	arguments[0].mutex = &mutexes[0];
	arguments[0].condition = &conditions[0];
	
	arguments[1].id = 1;
	arguments[1].flag = &flags[0];	// just like in arguments[0]
	arguments[1].counters = counters;
	arguments[1].mutex = &mutexes[0];
	arguments[1].condition = &conditions[0];
	
	arguments[2].id = 2;
	arguments[2].flag = NULL;		// not used
	arguments[2].counters = counters;
	arguments[2].mutex = &mutexes[0];
	arguments[2].condition = NULL;	// not used
	
	arguments[3].id = 3;
	arguments[3].flag = &flags[1];
	arguments[3].counters = &counters[2];
	arguments[3].mutex = &mutexes[1];
	arguments[3].condition = &conditions[1];
	
	arguments[4].id = 4;
	arguments[4].flag = &flags[1];
	arguments[4].counters = &counters[2];
	arguments[4].mutex = &mutexes[1];
	arguments[4].condition = &conditions[1];
	
	
	green_create(&threads[0], &test, &arguments[0]);
	green_create(&threads[1], &test, &arguments[1]);
	green_create(&threads[2], &hugger, &arguments[2]);
	green_create(&threads[3], &consumer, &arguments[3]);
	green_create(&threads[4], &producer, &arguments[4]);
	
	
	green_join(&threads[0]);
	green_join(&threads[1]);
	// trying to join hugger is pointless as it's perpetual loop
	green_join(&threads[3]);
	green_join(&threads[4]);
	
	printf("done\n");
	return 0;
}

// A 'test' thread tests condition variables and mutex synchronization
// It showcases data race and using a mutex to avoid it
// It also uses a conditional variable to make sure id 0 is executed before id 1
void *test(void *arg) {
	thread_args *args = (thread_args *)arg;
	
	int id = args->id;
	int *flag = args->flag;
	counter *counters = args->counters;
	green_mutex_t *mutex = args->mutex;
	green_cond_t *condition = args->condition;
	
	int loop = LOOP_COUNT;
	
	
	while (loop > 0) {
		if (*flag == id) {
			printf("thread %d: %d\n", id, --loop);
			do_counters(counters, mutex);
			*flag = (id + 1) % 2;
			green_cond_signal(condition);
		} else {
			green_cond_wait(condition, NULL);
		}
	}
	printf("thread %d is done\n", id);
}

// Hugger shares data race structures with tests 0 and 1 threads
//
// However unlike those threads it doesn't yield outside of mutex_locking
void *hugger(void *arg) {
#if SKIP_HUGGER
	return;
#endif

	thread_args *args = (thread_args *)arg;
	
	int id = args->id;
	
	counter *counters = args->counters;
	green_mutex_t *mutex = args->mutex;

	unsigned int i = 0;
	printf("Running hugger (%i), which doesn't yield!\n", id);
	while (1) {
		if (++i % 1000000 == 0) {
#if VERBOSE_HUGGER
			printf("Hugger at %i cycles, still no yield!\n", i);
#endif // VERBOSE_HUGGER
			//do_counters(counters, mutex);
		}
	}
}

// Consumer synchronizes on conditional variable and a mutex
//
// It showcases (somewhat obscurely for now) lack of deadlocks
// because green_cond_wait atomically releases mutex before yielding and retaking it after resuming
void *consumer(void *arg) {
	thread_args *args = (thread_args *)arg;
	
	int id = args->id;
	int *flag = args->flag;
	counter *counter = args->counters;
	green_mutex_t *mutex = args->mutex;
	green_cond_t *condition = args->condition;
	
	printf("Running consumer (%i)\n", id);
	
	green_mutex_lock(mutex);
	while (1) {
		if (*flag == 1) {
			int counter_value = counter->parts[0];
			
			if (is_corrupted(counter)) {
				printf("Consumer got corrupted counter that is meant to have value: %d\n", counter_value);
			} else {
				printf("Consumer got counter value: %d\n", counter_value);
			}
			green_mutex_unlock(mutex);
			break;
		} else {
			green_cond_wait(condition, mutex);
		}
	}
	
	printf("Consumer (%i) is done\n", id);
}

// Producer is the pair for consumer
void *producer(void *arg) {
	thread_args *args = (thread_args *)arg;
	
	int id = args->id;
	int *flag = args->flag;
	counter *counter = args->counters;
	green_mutex_t *mutex = args->mutex;
	green_cond_t *condition = args->condition;
	
	printf("Running producer (%i)\n", id);
	
	green_mutex_lock(mutex);
	while (1) {
		if (*flag == 0) {
			*flag = 1;
			
			for (int i = 0; i < COUNTER_SIZE; ++i)
				counter->parts[i] = id + 10;
			
			printf("Producer set counter to %i\n", counter->parts[0]);
			green_cond_signal(condition);
			green_mutex_unlock(mutex);
			break;
		} else {
			green_cond_wait(condition, mutex);
		}
	}
	
	printf("Producer (%i) is done\n", id);
}
